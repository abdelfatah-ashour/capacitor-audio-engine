# Rolling Segment Audio Recording: Instant-Stop Architecture (iOS + Android)This document describes an architecture and implementation checklist to achieve instant (<1s) stop responsiveness while recording continuously and only keeping the last X minutes of audio. It is tailored for this repository’s iOS (AVFoundation) and Android (MediaCodec/MediaMuxer or MediaRecorder) implementations.Goals:- Instant Stop: Return audio immediately when user presses stop.- Rolling Segments: Maintain the last X minutes using N rotating files.- File Readiness: Every segment is always a valid playable file (no heavy work at stop).- Background Processing: Any merging/trimming/cleanup occurs asynchronously.- Low Resources: Minimal CPU/RAM even during long sessions.- Cross-Platform Parity: Similar behavior on iOS and Android.## Core Strategy1. Dual-writer approach (optional but recommended for 0s stop):   - Segmented Recorder: Writes short fixed-length files (e.g., 60–120s) in a rolling buffer. These are the canonical truth for “last X minutes”.   - Continuous Recorder: Writes the entire session to one file in parallel so that “Stop” can return a file immediately with zero merge time. If last-X-minutes is required as a single file, trim the continuous file in background and resolve the final URL asynchronously.2. Rolling Buffer of Segments:   - Predefine segmentDurationSeconds (e.g., 60–120s). Shorter segments ⇒ faster index and lower rewrite cost; longer segments ⇒ fewer files and less muxer churn.   - Maintain a queue up to maxSegments = ceil(maxDurationSeconds / segmentDurationSeconds). When a new segment completes and buffer is full, delete the oldest.   - Each segment is an independently valid .m4a (iOS) or .m4a/.mp4 (Android) with correct headers. Never keep half-baked files.3. Instant Stop   - Stop returns immediately with either:     a) A list of existing segment files representing the last X minutes; or     b) The continuous file URL (already complete). If a single merged file is desired, trigger an async job to trim/concatenate into one output while the UI proceeds.4. Async Post-Stop Work   - If the app needs a single file of last X minutes:     - iOS: Use AVAssetExportSession or AVAssetWriter to trim the continuous file [t=(T-X)→T] or to concatenate the last K segments. Do this on a background queue.     - Android: Use MediaExtractor + MediaMuxer to trim continuous file or to stitch segments. Run on a background executor.   - Always guard against user exiting/locking screen; persist work state and cancel safely if needed.## iOS Implementation (AVFoundation)Key APIs:- AVAudioSession, AVAudioRecorder for lightweight AAC (.m4a) encoding.- AVAssetExportSession for trimming continuous file, AVMutableComposition + AVAssetExportSession for concatenating segments (if needed).Checklist:- Session setup: category .playAndRecord or .record, mode .measurement or .spokenAudio; allowBluetooth / mixWithOthers as per app needs.- Settings (aligned with repo defaults):  - sampleRate = 48000  - channels = 1  - format = kAudioFormatMPEG4AAC  - encoder bitrate = 128000- Segment duration: 60–120s recommended. Repository default is 300s (5 min). For faster rotation/fewer penalties, 60–120s is a sweet spot; adjust if your last-X window is small.- File naming: segment_YYYYMMDD_HHMMSS_idx.m4a to avoid collisions and simplify cleanup.- Start segmented recorder immediately and schedule a Timer (1s tick) to check swap times. On swap: stop current AVAudioRecorder, ensure file size > threshold, enqueue URL, delete oldest if over capacity, start next segment.- Continuous recorder: start/stop in parallel with segmented recorder. On stop, return continuous file URL instantly if it exists and is larger than minValidFileSize.- Stop path:  - Pause timers, stop both recorders.  - Immediately return:    - Either the continuous file URL; OR    - The array of segment URLs (already valid files).  - Dispatch background work for trim/merge if a single file is requested.- Waveform: keep a decimated buffer to avoid memory bloat (see README_WAVEFORM_SOLUTION.md).- Handle interruptions: on AVAudioSession interruptions or route changes, pause/resume carefully and keep durations accurate (do not lose segment integrity).- Cleanup: purge temp segments on init and after completion. Avoid blocking main thread.Pitfalls and fixes:- Slow stop due to merging at stop → avoid by keeping every segment valid and using continuous file for instant return, with async post-processing.- Header finalization delay → ensure you call stop() on AVAudioRecorder when segment ends; don’t do long composition sync on stop.- File I/O spikes → keep segments in app Documents/Library with background QoS for deletion and rotation.## Android Implementation (MediaRecorder / MediaCodec + MediaMuxer)Key APIs:- For simplicity and minimal CPU, MediaRecorder AAC is recommended for long recordings.- For advanced control or PCM capture, use AudioRecord + MediaCodec (AAC) + MediaMuxer.Checklist:- MediaRecorder config (recommended for low CPU):  - setAudioSource(MIC)  - setOutputFormat(MPEG_4)  - setAudioEncoder(AAC)  - setAudioEncodingBitRate(128000)  - setAudioSamplingRate(48000)  - Mono channel.- Segment rotation: schedule a timer; on each tick when segment time >= segmentDurationMs:  - stop() current MediaRecorder (fast), validate file length, enqueue file, delete oldest if over capacity, create/start new MediaRecorder for next segment.- Continuous recorder in parallel for instant stop.- Stop path: same as iOS (immediate return of continuous or list of segments); async trimming using MediaExtractor+MediaMuxer when single file needed.- Handle audio focus + interruptions: register AudioFocusRequest and pause/resume, keeping buffers consistent.- Clean up temp files robustly with retries.Pitfalls and fixes:- MediaMuxer finalize cost at stop if you keep one long file → mitigate with continuous file (already valid) and keep segments already final.- Memory bloat from PCM buffering → don’t buffer raw audio; always encode on-the-fly.## Choosing Segment Duration: Trade-offs- 30s segments:  - Pros: very quick roll, granular deletion, minimal lost work on crash.  - Cons: more file handles, more start/stop cycles, slightly higher overhead.- 60–120s segments (recommended):  - Pros: good balance of overhead and responsiveness.  - Cons: Slightly bigger merge set if you concatenate segments.- 300s segments:  - Pros: fewest files; stable.  - Cons: if last-X is small (e.g., 3–5 min), a single segment may exceed the window; also larger trimming window.Guidance: pick segmentDuration so that maxSegments is small (e.g., 5–12) and your last-X window is covered with a few segments.## Return Options on Stop1) Immediate multi-file return (zero work):   - Return array of ready segment URLs in chronological order covering last X minutes.   - UI can list or upload them as-is.2) Immediate single-file return (zero work with continuous):   - Return the continuous file URL for instant playback.   - If last-X-only is required, kick off background trim and notify when done.3) Deferred single-file return (async merge/trim):   - If no continuous recorder is used, return an interim list immediately and begin background concatenation of segments into one file.## Pseudo-code Sketch (iOS)- start(maxDurationSeconds?: Double)  - prepare AVAudioSession + settings  - startSegment()  - startContinuousRecorder()  - schedule timer for rotation- rotateSegment()  - currentSegmentRecorder.stop()  - validate file, enqueue, delete oldest if > capacity  - startSegment()- stop(options)  - stop timers  - stop segment + continuous recorders  - if options.returnContinuous: return continuousURL immediately  - else return segmentURLs  - if options.needSingleMerged: dispatch background trim/merge## Pseudo-code Sketch (Android)Similar to iOS using MediaRecorder or MediaCodec+MediaMuxer for segments and continuous recorder in parallel, using Handler/Executor for timers and background work.## Best Practices Checklist- Avoid long-running operations on stop; the stop path must be O(1) file operations only.- Validate every created segment: size > threshold, duration > small epsilon.- Keep a monotonic duration counter that ignores pauses for UX consistency.- All I/O off main thread; only dispatch small UI callbacks to main.- Use .m4a AAC for smallest cost and good quality at 128 kbps.- Keep minValidFileSize guard (e.g., 100 bytes) to filter corrupt files.- Ensure background tasks survive brief app state changes if needed.- Add structured logs for rotation, deletion, interruptions.## Repository Notes- iOS: SegmentRollingManager.swift already includes segmented recording, rolling buffer, and an optional continuous recorder with stopContinuousRecorderAndReturnFile() to enable instant returns.- Android: SegmentRollingManager.java mirrors the same approach.- Constants.swift holds tuned defaults for 48kHz mono AAC at 128 kbps.Adjust segmentDuration and maxDuration to fit your “last X minutes” needs, and prefer returning the continuous file immediately while scheduling any trimming/merging in the background to keep stop latency under 1s.