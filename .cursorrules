# Capacitor Audio Engine - Cursor Rules & AI Enhancement Guide

## Project Overview

This is a Capacitor plugin for high-quality audio recording using native device capabilities on iOS and Android. The plugin provides comprehensive audio functionality including recording, microphone management, and audio processing.

## Architecture & Design Patterns

### Core Architecture

- **Plugin Pattern**: Follows Capacitor plugin architecture with `CAPPlugin` base class
- **Manager Pattern**: Separate managers for recording (`RecordingManager`)
- **Delegate Pattern**: Uses delegate protocols for communication between components
- **Thread Safety**: All state operations use dedicated dispatch queues for thread safety

### Key Components

1. **CapacitorAudioEnginePlugin**: Main plugin class handling Capacitor bridge
2. **RecordingManager**: Handles all audio recording operations
3. **Constants**: Centralized configuration and constants

## Code Style & Conventions

### Swift Conventions

- Use `performStateOperation` wrapper for all state-changing operations
- Implement proper error handling with `NSError` domains
- Use `weak` references for delegates to prevent retain cycles
- Follow Swift naming conventions (camelCase for variables, PascalCase for types)
- Use `#if DEBUG` for debug-only logging

### Thread Safety

- All state operations MUST use `performStateOperation` wrapper
- Use dedicated dispatch queues for state management
- Avoid direct property access from multiple threads
- Implement proper synchronization for shared resources

### Error Handling

- Use descriptive error domains: "AudioEngine", "RecordingManager"
- Provide meaningful error messages in `NSLocalizedDescriptionKey`
- Log errors with context information
- Propagate errors through delegate methods

## Audio Implementation Guidelines

### Recording Features

- Support pause/resume functionality
- Handle audio interruptions gracefully
- Monitor recording duration in real-time
- Support multiple audio formats (MPEG4AAC default)

### Audio Session Management

- Configure audio session categories appropriately
- Handle audio interruptions and route changes
- Support background audio when needed
- Manage microphone permissions

## Constants & Configuration

### Audio Settings

- Default sample rate: 44100 Hz
- Default channels: 1 (mono)
- Default bitrate: 128000 bps
- Default format: MPEG4AAC
- Timer intervals: 1.0 second for progress updates

### Network & Resource Management

- Network timeout: 60 seconds
- Resource timeout: 120 seconds
- Network check timeout: 2 seconds
- Crossfade duration: 0.02 seconds

## Testing Guidelines

### Unit Testing

- Test all public methods with various input scenarios
- Mock dependencies (AVAudioPlayer, AVAudioRecorder)
- Test error conditions and edge cases
- Verify thread safety in concurrent operations

### Integration Testing

- Test audio session configuration
- Verify permission handling
- Test interruption handling
- Validate file operations

## Performance Considerations

### Memory Management

- Properly dispose of audio players and recorders
- Clear preloaded audio when no longer needed
- Use weak references to prevent memory leaks
- Monitor memory usage during long recordings

### Network Optimization

- Implement proper timeout handling for remote audio
- Use efficient data loading for large audio files
- Cache preloaded audio appropriately
- Handle network failures gracefully

## Security & Privacy

### Permission Handling

- Request microphone permissions appropriately
- Handle permission denial gracefully
- Provide clear permission request messages
- Support permission status checking

### File Security

- Use secure file paths for recordings
- Implement proper file cleanup
- Handle sensitive audio data appropriately
- Validate file operations

## Platform-Specific Considerations

### iOS Specific

- Use `AVAudioSession` for audio configuration
- Handle iOS audio interruptions properly
- Support iOS background audio modes
- Implement proper iOS permission handling

### Android Specific

- Use Android MediaRecorder for recording
- Handle Android audio focus properly
- Support Android storage permissions
- Implement Android-specific error handling

## Enhancement Guidelines

### Adding New Features

1. Follow existing architectural patterns
2. Implement proper error handling
3. Add comprehensive logging
4. Update constants as needed
5. Add appropriate tests
6. Update documentation

### Code Quality

- Use descriptive variable and method names
- Add comprehensive comments for complex logic
- Follow Swift style guidelines
- Implement proper error handling
- Add logging for debugging

### Performance Optimization

- Profile audio operations for performance
- Optimize memory usage
- Minimize audio latency
- Handle large files efficiently

## Common Patterns

### State Management

```swift
private func performStateOperation<T>(_ operation: () throws -> T) rethrows -> T {
    return try stateQueue.sync { try operation() }
}
```

### Error Handling

```swift
let error = NSError(domain: "AudioEngine", code: -1,
                   userInfo: [NSLocalizedDescriptionKey: "Descriptive error message"])
delegate?.recordingDidEncounterError(error)
```

### Logging

```swift
private func log(_ message: String) {
    #if DEBUG
    print("[AudioEngine] \(message)")
    #endif
}
```

### Delegate Pattern

```swift
protocol RecordingManagerDelegate: AnyObject {
    func recordingDidUpdateDuration(_ duration: Int)
    func recordingDidEncounterError(_ error: Error)
    // ... other delegate methods
}
```

## Future Enhancement Areas

### Planned Features

- Web platform support
- Advanced audio effects and filters
- Real-time audio processing
- Audio streaming capabilities
- Enhanced microphone management
- Audio format conversion

### Technical Improvements

- Audio engine optimization
- Better error recovery
- Enhanced debugging tools
- Performance monitoring
- Automated testing improvements

## Documentation Standards

### Code Documentation

- Document all public methods with clear descriptions
- Include parameter and return value documentation
- Provide usage examples for complex operations
- Document error conditions and handling

### API Documentation

- Maintain up-to-date README with examples
- Document platform-specific limitations
- Provide troubleshooting guides
- Include performance considerations

## Maintenance Guidelines

### Version Management

- Follow semantic versioning
- Maintain backward compatibility
- Document breaking changes
- Update dependencies regularly

### Code Review

- Review for thread safety
- Verify error handling
- Check memory management
- Validate performance implications

This guide should be updated as the codebase evolves and new patterns emerge.
